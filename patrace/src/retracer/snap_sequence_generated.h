// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SNAPSEQUENCE_RETRACER_IO_H_
#define FLATBUFFERS_GENERATED_SNAPSEQUENCE_RETRACER_IO_H_

#include "flatbuffers/flatbuffers.h"

namespace retracer {
namespace io {

struct MD5Digest;

struct Sequence;
struct SequenceBuilder;
struct SequenceT;

struct SnapSequence;
struct SnapSequenceBuilder;
struct SnapSequenceT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) MD5Digest FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t digest_[16];

 public:
  MD5Digest()
      : digest_() {
  }
  MD5Digest(flatbuffers::span<const uint8_t, 16> _digest) {
    flatbuffers::CastToArray(digest_).CopyFromSpan(_digest);
  }
  const flatbuffers::Array<uint8_t, 16> *digest() const {
    return &flatbuffers::CastToArray(digest_);
  }
};
FLATBUFFERS_STRUCT_END(MD5Digest, 16);

struct SequenceT : public flatbuffers::NativeTable {
  typedef Sequence TableType;
  uint32_t exit_frame = 0;
  std::vector<retracer::io::MD5Digest> frame_md5_array{};
};

struct Sequence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SequenceT NativeTableType;
  typedef SequenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXIT_FRAME = 4,
    VT_FRAME_MD5_ARRAY = 6
  };
  uint32_t exit_frame() const {
    return GetField<uint32_t>(VT_EXIT_FRAME, 0);
  }
  const flatbuffers::Vector<const retracer::io::MD5Digest *> *frame_md5_array() const {
    return GetPointer<const flatbuffers::Vector<const retracer::io::MD5Digest *> *>(VT_FRAME_MD5_ARRAY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_EXIT_FRAME) &&
           VerifyOffset(verifier, VT_FRAME_MD5_ARRAY) &&
           verifier.VerifyVector(frame_md5_array()) &&
           verifier.EndTable();
  }
  SequenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SequenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sequence> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SequenceBuilder {
  typedef Sequence Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exit_frame(uint32_t exit_frame) {
    fbb_.AddElement<uint32_t>(Sequence::VT_EXIT_FRAME, exit_frame, 0);
  }
  void add_frame_md5_array(flatbuffers::Offset<flatbuffers::Vector<const retracer::io::MD5Digest *>> frame_md5_array) {
    fbb_.AddOffset(Sequence::VT_FRAME_MD5_ARRAY, frame_md5_array);
  }
  explicit SequenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sequence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sequence>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sequence> CreateSequence(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t exit_frame = 0,
    flatbuffers::Offset<flatbuffers::Vector<const retracer::io::MD5Digest *>> frame_md5_array = 0) {
  SequenceBuilder builder_(_fbb);
  builder_.add_frame_md5_array(frame_md5_array);
  builder_.add_exit_frame(exit_frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sequence> CreateSequenceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t exit_frame = 0,
    const std::vector<retracer::io::MD5Digest> *frame_md5_array = nullptr) {
  auto frame_md5_array__ = frame_md5_array ? _fbb.CreateVectorOfStructs<retracer::io::MD5Digest>(*frame_md5_array) : 0;
  return retracer::io::CreateSequence(
      _fbb,
      exit_frame,
      frame_md5_array__);
}

flatbuffers::Offset<Sequence> CreateSequence(flatbuffers::FlatBufferBuilder &_fbb, const SequenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SnapSequenceT : public flatbuffers::NativeTable {
  typedef SnapSequence TableType;
  uint16_t magic = 7777;
  std::string timestamp{};
  std::string trace_name{};
  std::string patrace_version{};
  std::string android_release{};
  uint8_t android_version = 0;
  std::string phone_model{};
  std::string phone_manufacturer{};
  uint32_t frame_count = 0;
  uint32_t start_frame = 0;
  uint32_t end_frame = 0;
  uint16_t loop_count = 0;
  std::vector<std::unique_ptr<retracer::io::SequenceT>> record_array{};
};

struct SnapSequence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SnapSequenceT NativeTableType;
  typedef SnapSequenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAGIC = 4,
    VT_TIMESTAMP = 6,
    VT_TRACE_NAME = 8,
    VT_PATRACE_VERSION = 10,
    VT_ANDROID_RELEASE = 12,
    VT_ANDROID_VERSION = 14,
    VT_PHONE_MODEL = 16,
    VT_PHONE_MANUFACTURER = 18,
    VT_FRAME_COUNT = 20,
    VT_START_FRAME = 22,
    VT_END_FRAME = 24,
    VT_LOOP_COUNT = 26,
    VT_RECORD_ARRAY = 28
  };
  uint16_t magic() const {
    return GetField<uint16_t>(VT_MAGIC, 7777);
  }
  const flatbuffers::String *timestamp() const {
    return GetPointer<const flatbuffers::String *>(VT_TIMESTAMP);
  }
  const flatbuffers::String *trace_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TRACE_NAME);
  }
  const flatbuffers::String *patrace_version() const {
    return GetPointer<const flatbuffers::String *>(VT_PATRACE_VERSION);
  }
  const flatbuffers::String *android_release() const {
    return GetPointer<const flatbuffers::String *>(VT_ANDROID_RELEASE);
  }
  uint8_t android_version() const {
    return GetField<uint8_t>(VT_ANDROID_VERSION, 0);
  }
  const flatbuffers::String *phone_model() const {
    return GetPointer<const flatbuffers::String *>(VT_PHONE_MODEL);
  }
  const flatbuffers::String *phone_manufacturer() const {
    return GetPointer<const flatbuffers::String *>(VT_PHONE_MANUFACTURER);
  }
  uint32_t frame_count() const {
    return GetField<uint32_t>(VT_FRAME_COUNT, 0);
  }
  uint32_t start_frame() const {
    return GetField<uint32_t>(VT_START_FRAME, 0);
  }
  uint32_t end_frame() const {
    return GetField<uint32_t>(VT_END_FRAME, 0);
  }
  uint16_t loop_count() const {
    return GetField<uint16_t>(VT_LOOP_COUNT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<retracer::io::Sequence>> *record_array() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<retracer::io::Sequence>> *>(VT_RECORD_ARRAY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MAGIC) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyString(timestamp()) &&
           VerifyOffset(verifier, VT_TRACE_NAME) &&
           verifier.VerifyString(trace_name()) &&
           VerifyOffset(verifier, VT_PATRACE_VERSION) &&
           verifier.VerifyString(patrace_version()) &&
           VerifyOffset(verifier, VT_ANDROID_RELEASE) &&
           verifier.VerifyString(android_release()) &&
           VerifyField<uint8_t>(verifier, VT_ANDROID_VERSION) &&
           VerifyOffset(verifier, VT_PHONE_MODEL) &&
           verifier.VerifyString(phone_model()) &&
           VerifyOffset(verifier, VT_PHONE_MANUFACTURER) &&
           verifier.VerifyString(phone_manufacturer()) &&
           VerifyField<uint32_t>(verifier, VT_FRAME_COUNT) &&
           VerifyField<uint32_t>(verifier, VT_START_FRAME) &&
           VerifyField<uint32_t>(verifier, VT_END_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_LOOP_COUNT) &&
           VerifyOffset(verifier, VT_RECORD_ARRAY) &&
           verifier.VerifyVector(record_array()) &&
           verifier.VerifyVectorOfTables(record_array()) &&
           verifier.EndTable();
  }
  SnapSequenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SnapSequenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SnapSequence> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SnapSequenceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SnapSequenceBuilder {
  typedef SnapSequence Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_magic(uint16_t magic) {
    fbb_.AddElement<uint16_t>(SnapSequence::VT_MAGIC, magic, 7777);
  }
  void add_timestamp(flatbuffers::Offset<flatbuffers::String> timestamp) {
    fbb_.AddOffset(SnapSequence::VT_TIMESTAMP, timestamp);
  }
  void add_trace_name(flatbuffers::Offset<flatbuffers::String> trace_name) {
    fbb_.AddOffset(SnapSequence::VT_TRACE_NAME, trace_name);
  }
  void add_patrace_version(flatbuffers::Offset<flatbuffers::String> patrace_version) {
    fbb_.AddOffset(SnapSequence::VT_PATRACE_VERSION, patrace_version);
  }
  void add_android_release(flatbuffers::Offset<flatbuffers::String> android_release) {
    fbb_.AddOffset(SnapSequence::VT_ANDROID_RELEASE, android_release);
  }
  void add_android_version(uint8_t android_version) {
    fbb_.AddElement<uint8_t>(SnapSequence::VT_ANDROID_VERSION, android_version, 0);
  }
  void add_phone_model(flatbuffers::Offset<flatbuffers::String> phone_model) {
    fbb_.AddOffset(SnapSequence::VT_PHONE_MODEL, phone_model);
  }
  void add_phone_manufacturer(flatbuffers::Offset<flatbuffers::String> phone_manufacturer) {
    fbb_.AddOffset(SnapSequence::VT_PHONE_MANUFACTURER, phone_manufacturer);
  }
  void add_frame_count(uint32_t frame_count) {
    fbb_.AddElement<uint32_t>(SnapSequence::VT_FRAME_COUNT, frame_count, 0);
  }
  void add_start_frame(uint32_t start_frame) {
    fbb_.AddElement<uint32_t>(SnapSequence::VT_START_FRAME, start_frame, 0);
  }
  void add_end_frame(uint32_t end_frame) {
    fbb_.AddElement<uint32_t>(SnapSequence::VT_END_FRAME, end_frame, 0);
  }
  void add_loop_count(uint16_t loop_count) {
    fbb_.AddElement<uint16_t>(SnapSequence::VT_LOOP_COUNT, loop_count, 0);
  }
  void add_record_array(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<retracer::io::Sequence>>> record_array) {
    fbb_.AddOffset(SnapSequence::VT_RECORD_ARRAY, record_array);
  }
  explicit SnapSequenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SnapSequence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SnapSequence>(end);
    return o;
  }
};

inline flatbuffers::Offset<SnapSequence> CreateSnapSequence(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t magic = 7777,
    flatbuffers::Offset<flatbuffers::String> timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> trace_name = 0,
    flatbuffers::Offset<flatbuffers::String> patrace_version = 0,
    flatbuffers::Offset<flatbuffers::String> android_release = 0,
    uint8_t android_version = 0,
    flatbuffers::Offset<flatbuffers::String> phone_model = 0,
    flatbuffers::Offset<flatbuffers::String> phone_manufacturer = 0,
    uint32_t frame_count = 0,
    uint32_t start_frame = 0,
    uint32_t end_frame = 0,
    uint16_t loop_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<retracer::io::Sequence>>> record_array = 0) {
  SnapSequenceBuilder builder_(_fbb);
  builder_.add_record_array(record_array);
  builder_.add_end_frame(end_frame);
  builder_.add_start_frame(start_frame);
  builder_.add_frame_count(frame_count);
  builder_.add_phone_manufacturer(phone_manufacturer);
  builder_.add_phone_model(phone_model);
  builder_.add_android_release(android_release);
  builder_.add_patrace_version(patrace_version);
  builder_.add_trace_name(trace_name);
  builder_.add_timestamp(timestamp);
  builder_.add_loop_count(loop_count);
  builder_.add_magic(magic);
  builder_.add_android_version(android_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<SnapSequence> CreateSnapSequenceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t magic = 7777,
    const char *timestamp = nullptr,
    const char *trace_name = nullptr,
    const char *patrace_version = nullptr,
    const char *android_release = nullptr,
    uint8_t android_version = 0,
    const char *phone_model = nullptr,
    const char *phone_manufacturer = nullptr,
    uint32_t frame_count = 0,
    uint32_t start_frame = 0,
    uint32_t end_frame = 0,
    uint16_t loop_count = 0,
    const std::vector<flatbuffers::Offset<retracer::io::Sequence>> *record_array = nullptr) {
  auto timestamp__ = timestamp ? _fbb.CreateString(timestamp) : 0;
  auto trace_name__ = trace_name ? _fbb.CreateString(trace_name) : 0;
  auto patrace_version__ = patrace_version ? _fbb.CreateString(patrace_version) : 0;
  auto android_release__ = android_release ? _fbb.CreateString(android_release) : 0;
  auto phone_model__ = phone_model ? _fbb.CreateString(phone_model) : 0;
  auto phone_manufacturer__ = phone_manufacturer ? _fbb.CreateString(phone_manufacturer) : 0;
  auto record_array__ = record_array ? _fbb.CreateVector<flatbuffers::Offset<retracer::io::Sequence>>(*record_array) : 0;
  return retracer::io::CreateSnapSequence(
      _fbb,
      magic,
      timestamp__,
      trace_name__,
      patrace_version__,
      android_release__,
      android_version,
      phone_model__,
      phone_manufacturer__,
      frame_count,
      start_frame,
      end_frame,
      loop_count,
      record_array__);
}

flatbuffers::Offset<SnapSequence> CreateSnapSequence(flatbuffers::FlatBufferBuilder &_fbb, const SnapSequenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SequenceT *Sequence::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SequenceT>(new SequenceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sequence::UnPackTo(SequenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = exit_frame(); _o->exit_frame = _e; }
  { auto _e = frame_md5_array(); if (_e) { _o->frame_md5_array.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->frame_md5_array[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<Sequence> Sequence::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSequence(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sequence> CreateSequence(flatbuffers::FlatBufferBuilder &_fbb, const SequenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SequenceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _exit_frame = _o->exit_frame;
  auto _frame_md5_array = _o->frame_md5_array.size() ? _fbb.CreateVectorOfStructs(_o->frame_md5_array) : 0;
  return retracer::io::CreateSequence(
      _fbb,
      _exit_frame,
      _frame_md5_array);
}

inline SnapSequenceT *SnapSequence::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SnapSequenceT>(new SnapSequenceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SnapSequence::UnPackTo(SnapSequenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = magic(); _o->magic = _e; }
  { auto _e = timestamp(); if (_e) _o->timestamp = _e->str(); }
  { auto _e = trace_name(); if (_e) _o->trace_name = _e->str(); }
  { auto _e = patrace_version(); if (_e) _o->patrace_version = _e->str(); }
  { auto _e = android_release(); if (_e) _o->android_release = _e->str(); }
  { auto _e = android_version(); _o->android_version = _e; }
  { auto _e = phone_model(); if (_e) _o->phone_model = _e->str(); }
  { auto _e = phone_manufacturer(); if (_e) _o->phone_manufacturer = _e->str(); }
  { auto _e = frame_count(); _o->frame_count = _e; }
  { auto _e = start_frame(); _o->start_frame = _e; }
  { auto _e = end_frame(); _o->end_frame = _e; }
  { auto _e = loop_count(); _o->loop_count = _e; }
  { auto _e = record_array(); if (_e) { _o->record_array.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->record_array[_i] = std::unique_ptr<retracer::io::SequenceT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<SnapSequence> SnapSequence::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SnapSequenceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSnapSequence(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SnapSequence> CreateSnapSequence(flatbuffers::FlatBufferBuilder &_fbb, const SnapSequenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SnapSequenceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _magic = _o->magic;
  auto _timestamp = _o->timestamp.empty() ? 0 : _fbb.CreateString(_o->timestamp);
  auto _trace_name = _o->trace_name.empty() ? 0 : _fbb.CreateString(_o->trace_name);
  auto _patrace_version = _o->patrace_version.empty() ? 0 : _fbb.CreateString(_o->patrace_version);
  auto _android_release = _o->android_release.empty() ? 0 : _fbb.CreateString(_o->android_release);
  auto _android_version = _o->android_version;
  auto _phone_model = _o->phone_model.empty() ? 0 : _fbb.CreateString(_o->phone_model);
  auto _phone_manufacturer = _o->phone_manufacturer.empty() ? 0 : _fbb.CreateString(_o->phone_manufacturer);
  auto _frame_count = _o->frame_count;
  auto _start_frame = _o->start_frame;
  auto _end_frame = _o->end_frame;
  auto _loop_count = _o->loop_count;
  auto _record_array = _o->record_array.size() ? _fbb.CreateVector<flatbuffers::Offset<retracer::io::Sequence>> (_o->record_array.size(), [](size_t i, _VectorArgs *__va) { return CreateSequence(*__va->__fbb, __va->__o->record_array[i].get(), __va->__rehasher); }, &_va ) : 0;
  return retracer::io::CreateSnapSequence(
      _fbb,
      _magic,
      _timestamp,
      _trace_name,
      _patrace_version,
      _android_release,
      _android_version,
      _phone_model,
      _phone_manufacturer,
      _frame_count,
      _start_frame,
      _end_frame,
      _loop_count,
      _record_array);
}

inline const retracer::io::SnapSequence *GetSnapSequence(const void *buf) {
  return flatbuffers::GetRoot<retracer::io::SnapSequence>(buf);
}

inline const retracer::io::SnapSequence *GetSizePrefixedSnapSequence(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<retracer::io::SnapSequence>(buf);
}

inline bool VerifySnapSequenceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<retracer::io::SnapSequence>(nullptr);
}

inline bool VerifySizePrefixedSnapSequenceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<retracer::io::SnapSequence>(nullptr);
}

inline void FinishSnapSequenceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<retracer::io::SnapSequence> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSnapSequenceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<retracer::io::SnapSequence> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<retracer::io::SnapSequenceT> UnPackSnapSequence(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<retracer::io::SnapSequenceT>(GetSnapSequence(buf)->UnPack(res));
}

inline std::unique_ptr<retracer::io::SnapSequenceT> UnPackSizePrefixedSnapSequence(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<retracer::io::SnapSequenceT>(GetSizePrefixedSnapSequence(buf)->UnPack(res));
}

}  // namespace io
}  // namespace retracer

#endif  // FLATBUFFERS_GENERATED_SNAPSEQUENCE_RETRACER_IO_H_
